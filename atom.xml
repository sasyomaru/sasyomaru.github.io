<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[顿悟]]></title>
  <subtitle><![CDATA[捕捉技术与生活中的灵感]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://sparkshining.com//"/>
  <updated>2015-11-02T06:22:41.000Z</updated>
  <id>http://sparkshining.com//</id>
  
  <author>
    <name><![CDATA[流星泉]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Lambda表达式中的arguments]]></title>
    <link href="http://sparkshining.com/2015/11/02/arguments-in-lambda/"/>
    <id>http://sparkshining.com/2015/11/02/arguments-in-lambda/</id>
    <published>2015-11-02T06:07:58.000Z</published>
    <updated>2015-11-02T06:22:41.000Z</updated>
    <content type="html"><![CDATA[<p>最近在一个项目中遇到了这个坑，记下来，以警来者。</p>
<p>JavaScript在ES2015中初次引入了箭头函数（Arrow Function）这一俗称“lambda表达式”的概念，用来解决代码中this容易用错的问题（注意，this的定义从来就没有歧义，但确实是有点“反直觉”，容易被曾使用过其他语言的开发者误用）。想要了解这一特性，可以参阅
    <a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="external">这篇介绍ES6的文章</a>中“箭头函数”一节（原文中已对本文所述的问题做了介绍）。</p>
<p>在
    <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions-runtime-semantics-evaluation" target="_blank" rel="external">ES2015语言规范</a>中，明确规定了箭头函数不定义arguments的本地绑定。换句话说，如果在箭头函数中使用了arguments，则其值为生成该函数的参数列表，比如下面代码：
    <br>
    <figure class="highlight javascript">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td>
                <td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () =&gt; <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> praise = getFunction(<span class="string">'You suck!'</span>);</span><br><span class="line">praise(<span class="string">'You are great!'</span>);</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>如果在支持ES2015的浏览器（比如最新版的Chrome，笔者版本为46.0）上执行时你会发现，控制台会打印如下结果：
    <br>
    <figure class="highlight">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br></pre></td>
                <td class="code"><pre><span class="line">You suck!</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>而不是直觉上的You are great!</p>
<p>本来这个问题比较简单，规范上面这么定义的，这么做就是了。偏偏有人来搅局了：在ES2015尚未发布之前，
    <a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>（一个微软推出的语言，为JavaScript的超集，由于与Angular 2和React的合作而逐渐被人所知）就定义了类似的功能并最初起名为Lambda(现已改为采用跟ES2015一致的术语“箭头函数”，但截至笔者写作本文时，有些文档尚未更新，比如
    <a href="http://www.typescriptlang.org/Handbook#functions-lambdas-and-using-39this39" target="_blank" rel="external">这里</a>)。在TypeScript中，
    <strong>起初</strong>并未对Lambda中的arguments做任何处理，因此，arguments所指向的就是最终函数的参数列表。也就是说如果你在TypeScript中编写了上文的程序，得到的打印结果就是You are great!。
    <br>幸运的是，TypeScript的开发者即时地意识到了这一点（见
    <a href="https://github.com/Microsoft/TypeScript/issues/1609" target="_blank" rel="external">这个TypeScript问题</a>）。因此，如果在lambda中使用了arguments，你会得到如下的结果：</p>
<ol>
    <li>在TypeScript 1.5之前，该代码顺利通过编译，生成与E2015语义不一致的代码</li>
    <li>在TypeScript 1.5之后，如果编译目标是ES6，该代码会顺利通过编译，生成箭头函数</li>
    <li>在TypeScript 1.5之后，如果编译目标是ES3或者ES5，则该代码不会通过编译，错误如下：
        <figure class="highlight">
            <table>
                <tr>
                    <td class="gutter"><pre><span class="line">1</span><br></pre></td>
                    <td class="code"><pre><span class="line">error TS2496: The &#39;arguments&#39; object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.</span><br></pre></td>
                </tr>
            </table>
        </figure>
    </li>
</ol>]]></content>
    <summary type="html">
    <![CDATA[最近在一个项目中遇到了这个坑，记下来，以警来者。JavaScript在ES2015中初次引入了箭头函数（Arrow Function）这一俗称“lambda表达式”的概念，用来解决代码中this容易用错的问题。]]>
    
    </summary>
    
      <category term="JS" scheme="http://sparkshining.com/tags/JS/"/>
    
      <category term="天天向上" scheme="http://sparkshining.com/tags/%E5%A4%A9%E5%A4%A9%E5%90%91%E4%B8%8A/"/>
    
      <category term="技术" scheme="http://sparkshining.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的中医观]]></title>
    <link href="http://sparkshining.com/2015/10/19/traditional-chinese-medical-science/"/>
    <id>http://sparkshining.com/2015/10/19/traditional-chinese-medical-science/</id>
    <published>2015-10-19T12:48:40.000Z</published>
    <updated>2015-11-02T06:12:48.000Z</updated>
    <content type="html"><![CDATA[<p>最近也许是因为屠呦呦的诺贝尔获奖，千年大坑“中医是不是科学”又烽烟再起，争论愈演愈烈。思考良久，颇有心得，于是诉诸笔端。笔者知识有限，有些观点可能有误，欢迎斧正。</p>
<h3 id="中医是不是科学">中医是不是科学</h3>
<p>说实话，经过我的观察，我觉得这个问题其实大家彼此异议最小。别急，听我慢慢道来。
    <br>前两天看到了一篇文章，说到人们讨论的问题可以分为三类：一是事实性问题，就是讨论一见事情是否符合事实，多半这类问题可以转变成答案是“是”或者“否”的问题，比如今早吃没吃鸡蛋，这类问题有着唯一正确的结论，因为符合和没符合事实是互斥的；二是偏好性问题，就是你是否喜欢一个事物，比如红的好看还是绿的好看，这类问题没有错误的结论，因为不同人喜好不同；三是判断性问题，就是你对一个事物或现象的看法，这类问题的答案有多个，取决于你观察问题的角度。
    <br>然而在我看来，这个归类法存在一个陷阱，那就是一个问题如果要成为事实性问题，必须其表述上是没有歧义的，而且这个唯一的含义能够得到所有参与讨论问题的人的认同。
    <br>比如下面这个问题：太阳是否从东方升起？表面上看起来这是个事实性问题，答案只有“是”或者“否”，而且正确答案应该是“是”。但是你有没有想过，什么叫做“东方”，什么叫做“升起”呢？当你考虑过这些维度之后，你就会发现这个问题的答案不那么简单了：</p>
<ol>
    <li>太阳是不会自行升起的。我们只是在地球表面的一个观察点，基于地球自转的运动参照系观察到太阳在远离地心这个维度上有高度的上升变化。</li>
    <li>这个观察点不包括南北极两个点，因为南极点只有北方而北极点只有南方。</li>
    <li>东方表示的是以东方为中心，误差为23度26分21.448秒的一个方向的范围。否则，只有春分秋分那两天，太阳才是从非常接近东方的方向（还不能说是绝对的东方）升起的。有意思的是，对于我国绝大部分地区来说，冬至那天的太阳升起时的方向，距离正东北方反倒更接近些。</li>
</ol>
<p>那么，回到“中医是不是科学”这个问题：表面看起来，它是一个答案是“是”或者“否”的事实性问题。但是，如果认为这个问题有着唯一正确的结论，需要大家认可一个唯一的对“中医”和“科学”这两个概念的解释。很可惜，这样的无二义性的解释并不存在。笔者试着用一些没有二义性的方式来表述一些本人的看法，大家可以对照一下，是不是同自己的理解是一样的：</p>
<ol>
    <li>以下表述中，中医的定义为：主流的研究并发展“中医”这一概念的学者所认同的基于中国传统的对于医疗方向知识所总结的一套学说体系。西医的定义为：基于解剖学、物理学、化学、生物学、分子生物学等其他学科，辅以实验以及数据分析的对于医疗方向知识所总结的一套学说体系。</li>
    <li>中医学说体系与西医学说体系在问题定义以及验证方法尚存在分歧。换句话说，目前并不存在双方均认可的问题定义和验证方法。</li>
    <li>按照中医所提出的问题定义和验证方法，中医学说体系是可以通过实验方法验证的。</li>
    <li>目前尚无足够多的数据对中医学说体系的基础理论证实或者证伪。</li>
    <li>西医中主流学者对于是否存在一种方式将中医与西医两种学说统一起来存在争议。</li>
</ol>
<p>之所以列了这么多条，是因为“科学”这一概念的解释方式很多，这里只是采纳了主流的几种解释（可验证论、证伪论、科学共同体论）。如果您认同上面所说的所有条目，那么我们的观点是一致的。至于中医是不是科学，那取决于您如何定义“中医”与“科学”了。</p>
<h3 id="该如何对待中医">该如何对待中医</h3>
<p>医学与其他学科的不同在于，医学的学说建立存在着较大的滞后性。也就是说，无论是西医或者中医，都存在着大量无法解释的现象，也都存在很多不明机理但却有效的治疗方式。作为在一个存在大量未知现象的领域的一种学说体系，简单地说保留或者废除都是不合时宜的。其实完全可以按照市场化的方式，让其自己发展或者消亡。在某一领域，至少如果一种学说体系无法完全给出完整的解决方案之前，其他学说体系的存在都是有意义的。
    <br>作为每天需要使用医学结论的普通人，在面对治疗方案时，其实是一个对于投资回报的判断：如果我按照这个治疗方案进行投资，那么我有多大的可能会获得这个治疗方案所宣称的结果。这个时候，你要考虑的不是那个在诸多限制条件下的学术上的结论。治疗方案提出者是否了解学说本身，安慰剂等诸多浮动效应有多大可能发生都是考察的对象。比如说，假如有这样的一个理论，它虽然完全不能自洽，但是按照这个理论的手段能够保证百分之百出现安慰剂效应（当然很可能是由于某个尚未发现的原因）从而治好你的病，你愿不愿意采用呢？再比如，有一个医学理论，可以百分之百治好你的病，但是能够准确理解这个理论的医生万里也挑不出一个来，你愿不愿意采用眼前的医生基于这个理论提出来的解决方案呢？所以，是否采纳中/西医的解决方案，跟上面那个“中医是不是科学”问题完全是两个问题。这是一个个人做出的判断，风险自担，跟别人无关（只是不管是哪一种解决方案，准确地了解是否已研究过副作用或者是否有已知的副作用是基本的权利）。</p>
<h3 id="几个误区">几个误区</h3>
<p>我们在思考问题的时候，经常会走入一些误区。准确地识别出它们，是独立思考的一个必要的步骤。</p>
<ol>
    <li>在一个学说体系中，曾经提出的一个学说，如果没有被现在该学说体系的主流学者认同，则并不能视为是该学说体系的一部分。比如亚里士多德曾提出力是维持物体匀速运动的原因，我们不能认为这是物理学所秉持的观点。因此，如果你发现某古医书里写治疟疾要让大公鸡喊两声，也不能认为这是中医的观点。</li>
    <li>不能将一个学说的概念套用在另一个学说上并作为反驳的基础，这是因为两者问题定义不同。比如我们不能因为球面几何中不存在欧式几何中平行线这个概念而认为球面几何是错误的。因此，利用中药如果不能提供维生素就无法治疗维生素引发的疾病反驳中医也是没有道理的。</li>
    <li>观察不到的概念不等于不存在。你不能因为观察不到某些微观粒子而否定某些量子物理学说，不能因为看不到插件而否定这一编程概念，同样你也不能因为无法从解剖中看不到经脉而否定它（当然你可以用其他方式来否定）。</li>
    <li>表述方式原始的概念不等于不正确。有些概念有可能沿用了几千年，表述起来自然听起来不那么现代。但是概念是否正确跟这关系不大。比如苗这个概念用了上千年，却并不妨碍我们使用它来解释疫苗。中医的五行也并不是说你发烧的时候身体里就真的有物质在剧烈燃烧。只是如果一个学说体系想要得到发展，准确的阐释每个概念是非常必要的。</li>
</ol>]]></content>
    <summary type="html">
    <![CDATA[最近也许是因为屠呦呦的诺贝尔获奖，千年大坑“中医是不是科学”又烽烟再起，争论愈演愈烈。思考良久，颇有心得，于是诉诸笔端。笔者知识有限，有些观点可能有误，欢迎斧正。]]>
    
    </summary>
    
      <category term="天天向上" scheme="http://sparkshining.com/tags/%E5%A4%A9%E5%A4%A9%E5%90%91%E4%B8%8A/"/>
    
      <category term="科学" scheme="http://sparkshining.com/tags/%E7%A7%91%E5%AD%A6/"/>
    
      <category term="思考" scheme="http://sparkshining.com/categories/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通俗地解释第三方登录]]></title>
    <link href="http://sparkshining.com/2015/10/14/common-third-party-authentication/"/>
    <id>http://sparkshining.com/2015/10/14/common-third-party-authentication/</id>
    <published>2015-10-14T10:11:51.000Z</published>
    <updated>2015-10-14T10:14:47.000Z</updated>
    <content type="html"><![CDATA[<p>最近正在做SAML相关的事情，苦于没有一个第三方登录流程的通俗解释。结合以前做过的OpenID，试着自己解释一下。以下故事中机构名与人名均属化名，如有雷同，纯属巧合。</p>
<p>话说最近上海开了一家“人间天上”高级程序员休闲会所，供程序员在里面聊聊算法、思考人生。一天，有一个衣着入时的美女来找会所看门的王二狗，该美女自称是高级程序员，名叫郭小美，要求入会。王二狗又不是混程序圈的，咋知道这个人该不该放进去呢？于是王二狗请示安保主管雷老大。雷老大眼睛一瞪：老子又不是神仙，咋知道？
    <br>不过雷老大不愧是雷老大，经得多见得广，这点小事难不倒他。雷老大亲自接见郭小美，几个来回，事情就办成了：</p>
<ol>
    <li>雷老大拱了拱手：没听说过姑娘的名号，不知道是那路的？郭小美嫣然一笑：瞧您说的，没点背景还敢来？我是高级程序员协会的。</li>
    <li>雷老大大腿一拍：这就好办了，认识高级程序员协会会长盖茨比么？郭小美一愣：当然认识了，我干爹呀。</li>
    <li>雷老大嘿嘿一笑：这就更不是外人了。可惜这入会严格的规矩上面定的，我也没办法，要不你让盖茨比批个条子拿来，也让兄弟方便？郭小美皱了皱眉：真麻烦，好吧，就这么办！</li>
    <li>郭小美去找盖茨比，凭借着两人深厚的革命友谊，很快条子拿来了。上面一行字：兹证明郭小美（女，身份证号XXX，三围XXX）是高级程序员协会会员——盖茨比。笔锋苍劲，一看就是练过的。</li>
</ol>
<p>看到条子，雷老大满脸堆笑：不好意思呀，还让郭小姐多跑了一趟。回头招呼王二狗：傻站着干啥，赶紧办理入会！</p>]]></content>
    <summary type="html">
    <![CDATA[最近正在做SAML相关的事情，苦于没有一个第三方登录流程的通俗解释。结合以前做过的OpenID，试着自己解释一下。以下故事中机构名与人名均属化名，如有雷同，纯属巧合。]]>
    
    </summary>
    
      <category term="天天向上" scheme="http://sparkshining.com/tags/%E5%A4%A9%E5%A4%A9%E5%90%91%E4%B8%8A/"/>
    
      <category term="模型解释" scheme="http://sparkshining.com/tags/%E6%A8%A1%E5%9E%8B%E8%A7%A3%E9%87%8A/"/>
    
      <category term="技术" scheme="http://sparkshining.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[zone.js简介]]></title>
    <link href="http://sparkshining.com/2015/10/10/introduction-to-zone-js/"/>
    <id>http://sparkshining.com/2015/10/10/introduction-to-zone-js/</id>
    <published>2015-10-10T10:15:33.000Z</published>
    <updated>2015-10-12T12:06:07.000Z</updated>
    <content type="html"><![CDATA[<p>当你使用Angular 2的时候，你会惊喜地发现你不再需要$rootScope.$apply了，即使你直接调用addEventListener挂载一个事件处理器偷偷修改了模型，也不需要通知Angular。Angular似乎能够“未卜先知”地知道你的所有小动作。这一切的功劳都归功于zone.js。</p>
<p>zone.js的github地址见
    <a href="https://github.com/angular/zone.js" target="_blank" rel="external">这里</a>。原代码库提供了一个
    <a href="https://www.youtube.com/watch?v=3IqtmUscE_U" target="_blank" rel="external">ng-conf上的video</a>(需翻墙)来解释这个库的背景。注意
    <strong>zone.js是一个独立的库，并不依赖于Angular</strong>，所以你无需担心被“某些别有用心的大户”挟持了。</p>
<p>简单地说，zone.js允许你为一段代码及其衍生出的代码提供了一个统一的上下文（zone.js称之为zone）。这个概念类似Node中的domain或者Java中的thread locals。
    <br>能够在源于同一段代码的有着不同stack trace的程序间共享数据是一件很诱人的事情。比如说，你想统计程序的执行时间，然而你却有这样的一段奇葩程序：它自己要执行1秒，并且触发一个异步的操作；这个异步的操作又执行了3秒。如果你能够在这两段程序间共享数据，这个问题就简单多了。
    <br>当然，你完全可以自己通过给每个入口的地方都加入一段代码的方式来解决这个问题，但是你会更希望能够使用一种类似zone.js提供的这种“面向切面”的优雅解决方案。</p>
<p>首先，如果用这样的方式来运行你的程序：
    <br>
    <figure class="highlight javascript">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br></pre></td>
                <td class="code"><pre><span class="line">zone.run(yourCode);</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>这样你的这段代码以及其衍生的代码，包括：</p>
<ol>
    <li>它注册的浏览器事件处理器</li>
    <li>它通过setTimeout和setInterval在未来执行的代码</li>
</ol>
<p>以及衍生代码所衍生的代码就共享一个zone了。</p>
<p>那么，怎么使用这个zone呢？你可以通过类似下面这段代码这样通过zone.fork来插入一些监听器：
    <br>
    <figure class="highlight javascript">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td>
                <td class="code"><pre><span class="line">zone.fork(&#123;</span><br><span class="line">  beforeTask: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在每段代码执行前都会执行的代码</span></span><br><span class="line">  &#125;,</span><br><span class="line">  afterTask: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在每段代码执行后都会执行的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).run(youCode);</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>比如，在beforeTask记录下开始时间，afterTask时记录下结束时间、与开始时间比较算出执行时间并且累加，你就可以解决前文说过的那个问题了。本文开头的Angular 2的$rootScope.$apply的迷雾也就解开了，因为Angular 2使用了zone并且在afterTask时帮你执行这个了。</p>
<p>zone.js的实现原理很简单，就是mock掉你的每个入口位置。多么地简单粗暴啊！但是非常有效。</p>
<p>说了这么多，来看一个最最简单地例子吧：我们想在每次执行代码(主函数、事件监听函数和setTimeout加入的macrotask)的前后各打印一行log。</p>
<p>首先，我们新创建一个空文件夹来装例子所需的文件。
    <br>然后，因为zone支持bower，我们通过在该文件夹中运行下面的命令(有关bower使用，请见
    <a href="http://bower.io/#getting-started" target="_blank" rel="external">这里</a>)下载zone：
    <br>
    <figure class="highlight bash">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br></pre></td>
                <td class="code"><pre><span class="line">bower install zone</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>然后，在目录下创建index.html文件。那么默认情况下，相对于html文件，zone.js文件的位置应该是”bower_components/zone/dist/zone.js”。html文件内容如下
    <br>
    <figure class="highlight html">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td>
                <td class="code"><pre><span class="line"><span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Zone.js Basic Demo<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"./bower_components/zone/dist/zone.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>Basic Example<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"trigger"</span>&gt;</span>Run async code<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * This is a simple example of async stack traces with zones</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Run main'</span>);</span><br><span class="line">        trigger.addEventListener(<span class="string">'click'</span>, clickHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Run click handler'</span>);</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Run macro task'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Bootstrap the app</span><br><span class="line">     */</span></span><br><span class="line">    zone.fork(&#123;</span><br><span class="line">        beforeTask: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Enter zone'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        afterTask: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Leave zone'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).run(main);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>然后你可以用类似
    <a href="https://github.com/indexzero/http-server" target="_blank" rel="external">http-server</a>的方法来部署这个文件并用浏览器访问。
    <br>在页面加载后，你会在控制台看到如下信息
    <br>
    <figure class="highlight python">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td>
                <td class="code"><pre><span class="line">Enter zone</span><br><span class="line">Run main</span><br><span class="line">Leave zone</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>当点击页面中的按钮时，控制台会打印如下信息
    <br>
    <figure class="highlight python">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td>
                <td class="code"><pre><span class="line">Enter zone</span><br><span class="line">Run click handler</span><br><span class="line">Leave zone</span><br><span class="line">Enter zone</span><br><span class="line">Run macro task</span><br><span class="line">Leave zone</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>值得指出的是，zone.js那个文件本身并不支持microtask（有关macrotask和microtask，日后我会专门写一篇文章来解释）。如果想支持microtask，你需要使用库里面的zone-microtask.js。这个文件比zone.js大很多，主要的原因是它用es6-promise完全替换掉了浏览器内置的Promise。</p>]]></content>
    <summary type="html">
    <![CDATA[当你使用Angular 2的时候，你会惊喜地发现你不再需要$rootScope.$apply了，即使你直接调用addEventListener挂载一个事件处理器偷偷修改了模型，也不需要通知Angular。Angular似乎能够“未卜先知”地知道你的所有小动作。这一切的功劳都归功于zone.js。]]>
    
    </summary>
    
      <category term="JS" scheme="http://sparkshining.com/tags/JS/"/>
    
      <category term="天天向上" scheme="http://sparkshining.com/tags/%E5%A4%A9%E5%A4%A9%E5%90%91%E4%B8%8A/"/>
    
      <category term="技术" scheme="http://sparkshining.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何生成一个安全的随机数]]></title>
    <link href="http://sparkshining.com/2015/10/09/js-safe-get-random/"/>
    <id>http://sparkshining.com/2015/10/09/js-safe-get-random/</id>
    <published>2015-10-09T09:54:03.000Z</published>
    <updated>2015-10-12T08:51:17.000Z</updated>
    <content type="html"><![CDATA[<p>提起随机数，大家的第一反应一般是Math.random。然而，
    <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.8.2.14" target="_blank" rel="external">ECMAScript里面</a>(中文版见
    <a href="http://lzw.me/pages/ecmascript/#457" target="_blank" rel="external">这里</a>)并没有规定用什么算法来实现这个API，只是规定了生成的数字应该在[0, 1)内近似均匀分布。这就使得很多引擎实现在实现时采用了比较简单地算法，并不保证随机数的不可预测。
    <br>这样的随机数显然不能用于数据加密。那么，有什么API可以获得一个安全的随机数呢？</p>
<p>如果是Node.js，你可以使用
    <a href="https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback" target="_blank" rel="external">crypto.randomBytes(size[, callback])</a>这个API，比如下面的code获得了一个包含4个byte的随机数：
    <br>
    <figure class="highlight javascript">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td>
                <td class="code"><pre><span class="line">crypto.randomBytes(<span class="number">4</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, buf</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(buf.length);</span><br><span class="line">  <span class="built_in">console</span>.log(buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">2</span>], buf[<span class="number">3</span>]);</span><br><span class="line">&#125;);</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>那浏览器端怎么办呢，你可以使用
    <a href="http://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues" target="_blank" rel="external">crypto.getRandomValues(array)</a>这个API，现在很多浏览器都支持这个API了（具体浏览器支持情况请见
    <a href="http://caniuse.com/#feat=getrandomvalues" target="_blank" rel="external">这里</a>），比如下面的code获得了一个Uint32（4个byte）的随机数：
    <br>
    <figure class="highlight javascript">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td>
                <td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">1</span>);</span><br><span class="line">crypto.getRandomValues(buffer);</span><br><span class="line"><span class="built_in">console</span>.log(buffer[<span class="number">0</span>]);</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>搞定，收工！</p>]]></content>
    <summary type="html">
    <![CDATA[提起随机数，大家的第一反应一般是Math.random。然而，ECMAScript里面并没有规定用什么算法来实现这个API，只是规定了生成的数字应该在[0, 1)内近似均匀分布。这就使得很多引擎实现在实现时采用了比较简单地算法，并不保证随机数的不可预测。这样的随机数显然不能用于数据加密。那么，有什么API可以获得一个安全的随机数呢？]]>
    
    </summary>
    
      <category term="JS" scheme="http://sparkshining.com/tags/JS/"/>
    
      <category term="天天向上" scheme="http://sparkshining.com/tags/%E5%A4%A9%E5%A4%A9%E5%90%91%E4%B8%8A/"/>
    
      <category term="技术" scheme="http://sparkshining.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义JS对象的序列化与反序列化过程]]></title>
    <link href="http://sparkshining.com/2015/10/08/jsobject-serialization-deserialization/"/>
    <id>http://sparkshining.com/2015/10/08/jsobject-serialization-deserialization/</id>
    <published>2015-10-08T08:32:08.000Z</published>
    <updated>2015-11-02T06:07:42.000Z</updated>
    <content type="html"><![CDATA[<p>先更正一个概念，JSON是一种数据表达的格式（见
    <a href="http://www.ietf.org/rfc/rfc4627.txt" target="_blank" rel="external">RFC-4627</a>），就像我们平常说的xml、csv一样。它本身不是数据，也不依赖于具体编程语言。用.net、Java或者Python都能生成JSON格式的数据。
    <br>
    <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.12" target="_blank" rel="external">JSON对象(JSON Object)</a>(中文文档见
    <a href="http://lzw.me/pages/ecmascript/#609" target="_blank" rel="external">这里</a>)这个术语是有的，它是全局对象众多属性中的一个。它包含两个函数：parse和stringify，用于解析和构造JSON文本。但是JSON对象跟
    <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5" target="_blank" rel="external">对象初始化(Object Initialiser)</a>(中文文档见
    <a href="http://lzw.me/pages/ecmascript/#159" target="_blank" rel="external">这里</a>)是两码事，后者用于以直接量的方式初始化一个对象，比如
    <br>
    <figure class="highlight javascript">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br></pre></td>
                <td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; myField: <span class="string">'myValue'</span> &#125;;</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>注意不要弄混了。</p>
<p>其实JSON.stringify和JSON.parse的参数都不止一个，根据ECMAScript 5.1规范，两者的声明分别是：
    <br>
    <figure class="highlight stylus">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td>
                <td class="code"><pre><span class="line">JSON.<span class="function"><span class="title">stringify</span><span class="params">(value [ , replacer [ , space ] ] )</span></span></span><br><span class="line">JSON.<span class="function"><span class="title">parse</span><span class="params">(text [ , reviver ] )</span></span></span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>这就使得我们可以控制序列化和反序列化的过程。比如下面的代码模拟了一个让函数在序列化并反序列化后仍旧保持不丢失的情况。
    <br>
    <figure class="highlight javascript">
        <table>
            <tr>
                <td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td>
                <td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  myField: <span class="string">'myValue'</span>,</span><br><span class="line">  myFunction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'function is not able to be serialized'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'__function'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> JSONString = <span class="built_in">JSON</span>.stringify(obj, replacer);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reviver</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="string">'__function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'function restored by reviver'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> restoredObj = <span class="built_in">JSON</span>.parse(JSONString, reviver);</span><br><span class="line">restoredObj.myFunction();</span><br></pre></td>
            </tr>
        </table>
    </figure>
</p>
<p>值得注意的是，除了函数外，replacer还支持其他几种类型。有兴趣的请翻阅
    <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3" target="_blank" rel="external">ECMAScript规范相关部分</a>(中文版见
    <a href="http://lzw.me/pages/ecmascript/#614" target="_blank" rel="external">这里</a>)。最有意思的是，你还可以通过定义toJSON函数来自定义序列化的过程。</p>]]></content>
    <summary type="html">
    <![CDATA[JSON.stringify和JSON.parse的第二个参数使得我们可以控制序列化和反序列化的过程。]]>
    
    </summary>
    
      <category term="JS" scheme="http://sparkshining.com/tags/JS/"/>
    
      <category term="天天向上" scheme="http://sparkshining.com/tags/%E5%A4%A9%E5%A4%A9%E5%90%91%E4%B8%8A/"/>
    
      <category term="技术" scheme="http://sparkshining.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开篇志]]></title>
    <link href="http://sparkshining.com/2015/08/27/hello-world/"/>
    <id>http://sparkshining.com/2015/08/27/hello-world/</id>
    <published>2015-08-27T11:23:29.000Z</published>
    <updated>2015-10-12T11:51:47.000Z</updated>
    <content type="html"><![CDATA[<p>一个雨后的黄昏，一杯清茶，一支笔，一张纸。就此开始。</p>
<p>其实上大学那会儿，还是个挺矫情的人，没事就写点东西。等工了作，成了家，有了孩子，事情一多，也就慢慢变得大条了。
    <br>当然，也是生活舒适了，没那么多伤春悲秋的事。
    <br>一晃七八年，猛然发现竟然没留下什么印象。偶尔翻翻照片，一片陌生。
    <br>觉得有点对不起自己，也对不起那些重要的人。本是萍水相逢，却逐渐印入对方的生活。其间曲曲折折，竟这样逐渐淡了。
    <br>未来之路还很长，不求别的，只求能留下些印记，为自己，也为重要的人。</p>
<p>工作亦是如此，几年下来，颇有些心得。本是好为人师的，只因太懒，几次冲动最后都只是动了动嘴皮子。
    <br>其间，跟着公司一位前辈一起出了一本书，写的是一个小众的框架，出版后据说风评还不错。
    <br>那段时间废寝忘食，写的很是酣畅淋漓。等书出版以后，懒心又起，原来CSDN的博客就这样彻底荒掉了。</p>
<p>我虽然喜欢技术，却只限于工作或是猎奇。生活中却是保守得很。
    <br>在移动上网3G、4G如火如荼的时候，我还揣着一台老旧的Nokia，除了打电话发短信，跟网络没有半毛钱关系。
    <br>支付宝是去年才开始用的，滴滴打车是上个月才开始用的。人家咣咣往里砸钱，补贴满天飞的时候，我依旧去超市买东西，坐地铁上下班。
    <br>个人网站也是这样，虽然我的工作一直跟网页相关，却从来没有一个自己的网站。
    <br>没什么，不感冒而已。</p>
<p>偶然一个机会，一时冲动，买了个域名。买完之后，花了几分钟做了个巨丑陋的“网站正在建设中”的页面，而后就放在那儿。
    <br>结果没出两个月，接了无数来自百度推广市场部的电话，后来连自己都烦了。既然已经被骚扰了，不妨就写点什么吧。</p>
<p>花了些时间，搞了个自己看着还算凑合的模板，用hexo搭了个台子。就这样，今天算是开张了。
    <br>其实这里充其量只能算是个自留地，能记录下生活技术上的点点滴滴，也就知足了。</p>]]></content>
    <summary type="html">
    <![CDATA[一个雨后的黄昏，一杯清茶，一支笔，一张纸。就此开始。]]>
    
    </summary>
    
      <category term="瞎扯" scheme="http://sparkshining.com/tags/%E7%9E%8E%E6%89%AF/"/>
    
      <category term="生活" scheme="http://sparkshining.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>