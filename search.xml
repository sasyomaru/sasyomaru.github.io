[{"title":"浏览器兼容之聚焦相关的事件","url":"http://sparkshining.com/2016/05/31/focus-management-in-browsers/","content":"<p>常年做前端，哪能不恶心？虽然这两年浏览器兼容性是越来越好了，但还是会偶尔遇到一些其他问题，让你欲哭无泪，求死不能。今天我们就来八一八浏览器中跟聚焦（focus）有关的事件。\n    <br>这个世界上有两种人：使鼠标的和使键盘的。鼠标是二维定位，精确度高；键盘是十个输入（像我爸爸那样的修炼二指禅的除外），速度非常。正因为各有利弊，所以虽然双方都看对方不太顺眼，也只能凑合着过。\n    <br>焦点这一设计是为键盘使用者准备的：当你双手飞速敲打键盘的时候，有一个问题也就来了：电脑怎么知道你在往哪儿输入呢？于是，在网页中，我们定义了一个激活元素（active element)，键盘输入都是发往这个元素的。当用户用鼠标点击另一个可聚焦的元素或者按Tab键时，网页激活的元素也会响应的发生变化。</p>\n<p>在浏览器中，跟焦点有关的API有以下这些(见\n    <a href=\"https://w3c.github.io/html/index.html\" target=\"_blank\" rel=\"external\">HTML5 Editor’s draft</a>)：\n    <br>1个属性——document.activeElement，用于获取文档中当前获得焦点的元素\n    <br>1个方法——element.focus()，用于让元素获得焦点\n    <br>若干\n    <a href=\"https://www.w3.org/TR/uievents/#events-focusevent\" target=\"_blank\" rel=\"external\">事件</a>——blur, focus, focusin, focusout</p>\n<p>现在让我们看看各浏览器的表现吧。为了易于对比，笔者使用了Chrome 50, Firefox 46, IE 11和Edge 20作为测试对象。Safari因为跟Chrome采用同样的引擎，因此结果与Chrome 50完全一致，这里不单独列出。测试代码见\n    <a href=\"https://jsfiddle.net/sasyomaru/yamkxf26/\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<h4 id=\"测试1-鼠标点击改变焦点\">\n    <a href=\"#测试1-鼠标点击改变焦点\" class=\"headerlink\" title=\"测试1 鼠标点击改变焦点\"></a>测试1 鼠标点击改变焦点</h4>\n<p>初始时焦点位于输入框1上，通过点击输入框2将焦点移到它上面。</p>\n<p>各浏览器中事件触发先后顺序如下：</p>\n<table>\n    <thead>\n        <tr>\n            <th>浏览器</th>\n            <th>事件链</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>Chrome 50</td>\n            <td>输入框2上mousedown -&gt; 输入框1上blur -&gt; 输入框1上focusout -&gt; 输入框2上focus -&gt; 输入框2上focusin -&gt; 输入框2上mouseup -&gt; 输入框2上click</td>\n        </tr>\n        <tr>\n            <td>Firefox 46</td>\n            <td>输入框2上mousedown -&gt; 输入框1上blur -&gt; 输入框2上focus -&gt; 输入框2上mouseup -&gt; 输入框2上click</td>\n        </tr>\n        <tr>\n            <td>IE 11</td>\n            <td>输入框2上mousedown -&gt; 输入框1上focusout -&gt; 输入框2上focusin -&gt; 输入框1上blur -&gt; 输入框2上focus -&gt; 输入框2上mouseup -&gt; 输入框2上click</td>\n        </tr>\n        <tr>\n            <td>Edge 20</td>\n            <td>输入框2上mousedown -&gt; 输入框1上focusout -&gt; 输入框1上blur -&gt; 输入框2上focus -&gt; 输入框2上focusin -&gt; 输入框2上mouseup -&gt; 输入框2上click</td>\n        </tr>\n    </tbody>\n</table>\n<p>所有浏览器的焦点转移行为都发生在鼠标压下的阶段（mousedown），鼠标抬起（mouseup）对焦点没有任何影响。\n    <br>可以看出主要分歧在于focusout和focusin的触发时间，Chrome认为两者只是相应事件（blur和focus）的冒泡版本，因此在相应事件后触发；而IE认为两者其实是预览事件（preview），因此在相应事件前触发；Edge是一个折中；而Firefox干脆就没有这两个事件（莫非因为看不清楚趋势，先明哲保身一下？）。\n    <br>值得一提的是，还未定稿的\n    <a href=\"https://www.w3.org/TR/uievents/#events-focusevent-event-order\" target=\"_blank\" rel=\"external\">界面事件规范</a>中的定义，似乎与IE的行为更为一致。</p>\n<p>那么，在这么多事件当中（mousedown / mouseup / click，focus / blur / focusin / focusout），焦点到底是什么时候转移的呢？\n    <br>这个问题上，浏览器自动分为了两个阵营：IE（包括Edge）一方当focusout触发的时候，焦点就已经转移到了新的输入框上；非IE（Firefox / Chrome）一方在失去焦点阶段内，焦点先回到默认值body上，而在获得焦点阶段，焦点才会转移到新的输入框上。</p>\n<p>与所有其他浏览器都不同，IE 11默认情况下所有display为block或者table的元素都可以获得焦点。但Edge却与Chrome等非IE浏览器一致，典型的兄弟反水啊。</p>\n<h4 id=\"测试2-Tab键改变焦点\">\n    <a href=\"#测试2-Tab键改变焦点\" class=\"headerlink\" title=\"测试2 Tab键改变焦点\"></a>测试2 Tab键改变焦点</h4>\n<p>初始时焦点位于输入框1上，通过按下键盘上Tab键将焦点移到下一个输入框（输入框2）上</p>\n<p>各大浏览器的事件触发与鼠标改变焦点基本一致，只不过触发的是keydown和keyup，而不是mousedown或mouseup，也没有click事件。不过这中间还是有两点值得注意的。</p>\n<ol>\n    <li>Firefox 46会在紧随着keydown之后，再触发一次keypress；而其他浏览器不会。</li>\n    <li>如果是按住Tab键进行连续的焦点改变时，会在每个聚焦元素上分别触发keydown（Firefox会额外触发keypress），但是除最后一次外不会触发keyup事件。</li>\n</ol>\n<p>笔者试图寻找规范中的定义，可以没有找到。其实这也正常，定义规范本就是一个特别繁杂的工程，难免挂一漏万。更何况规范定义好了，各家浏览器厂商是否执行还是个未知数。HTML5搞出来两套不就是因为大家没法一起玩的结果么？论天下大事，分久必合，合久必分，习惯就好。</p>"},{"title":"经济危机中的倒牛奶行为","url":"http://sparkshining.com/2015/12/16/dump-milk/","content":"<p>最近在看经济学的书，确实脑洞大开。很多以前解释不清的问题，终于有了连贯的逻辑链条。</p>\n<p>当年学马克思主义政治经济学的时候，那个经济危机中美国奶牛农场主把牛奶倒入海中的故事甚是触目惊心。然而，笔者完全无法认同“这反映了资本家剥削穷人的本质”这种观点。商人最懂得做顺水人情从而获取长远利益。因此，一定存在着一种理性且合乎逻辑的机制，来促成农场主做了如此的决策。</p>\n<p>笔者看过的一篇材料显示，在1931年-1934年在美国中西部发生了奶农罢工事件，在这次事件中，部分有组织的罢工奶农强行倾倒其他奶农的牛奶。然而，一者笔者无法验证这则材料的真伪，二者倒牛奶事件不止发生在上述时间和上述地区，因此这个事件不在笔者讨论之列。</p>\n<p>先让我们看看一个很官方的解释：倒牛奶会改变供求关系从而影响价格。这个答案相当具有迷惑性，因为推翻这句话就意味着推翻经济学大厦基础的需求曲线。但是请注意，这里有个重大的思维陷阱：这个答案陈述本身没有任何问题，而漏洞在于，这个答案跟问题之间并没有必然联系。\n    <br>首先，价格从来都不是资本家考虑的因素，利润才是。所以从来就没有“影响价格”这种需求，人们的需求是不要影响利润。\n    <br>当我们关注利润的时候，就出现了一个无法解释的问题，那就是如果倒牛奶的人不属于某个拥有强大统筹能力的组织，就会面临一个风险：要是其他人不倒，我不就白倒了？然而迄今为止，如果我们不考虑有组织的罢工奶农这件事，笔者没有看到任何资料表明这些倒牛奶的人是有组织的。\n    <br>当然这些都是小问题，这个观点最直接的漏洞在于，倒牛奶是否是为了改变供求关系。我们必须承认，倒牛奶确实会改变供求关系，但不见得这就是倒牛奶的原因。这就好比我吃火锅会花人民币，但是我吃火锅在绝大多数情况下不是因为我想花掉一笔钱，而是因为我想吃顿饭。衡量一件行为是否是一个原因造成的最简单的办法，就是看这个原因不再存在时，这个行为是否还会继续。根据原文，在奶农倒牛奶的同时，有些人是想喝牛奶喝不到的，也就是说倒牛奶行为并没有因为过剩需求的出现而停止。因此，改变供求关系是倒牛奶的”果”而不是“因”。如果倒牛奶是为了改变供求关系，那么这个时候明智的牛奶生产者应该做的是：找到这批喝不到牛奶的人并把牛奶以极低的价格卖给他们。</p>\n<p>如果当你仔细地开始考虑“找到这批喝不到牛奶的人并卖给他们”这个解决方案的时候，也许你已经想到我要说的了：倒牛奶是交易成本高于收益的结果。这里交易成本高体现为三个方面：\n    <br>一是信息获取成本，生产牛奶的人没有办法获知谁想喝牛奶喝不到；这个问题在互联网时代似乎更容易解决一些，淘宝小店一开需求立即来，只要价格够低不怕没人买。\n    <br>二是仓储成本，由于牛奶保质期短，不易储藏，所以生产牛奶的人一般不会大规模的建立仓储，而是依赖快速销售；临时建立仓储成本太高，生产牛奶的人无法支付。假如出现了一种技术，喊一嗓子把牛奶扔到田地里就能保存三十年，没准还会有人趁机抄底呢。\n    <br>三是运输成本，哪怕生产牛奶的人愿意施舍给别人，运输的费用也是一笔不菲的支出。有两个假想的实验可以解释这一问题：假如倒牛奶的地方旁边就有人拿着容器等着喝牛奶，是否生产牛奶的人会阻止这一行为？假如倒牛奶的地方远离农场，是否生产牛奶的人会愿意将牛奶远距离运输到倾倒地点进行倾倒？显而易见，是运输成本阻碍了善良。</p>\n<p>综上，倒牛奶是由于供求关系突变，导致供方交易所得低于交易成本的结果。跟人性没有任何关系，绝对的“你跺你也麻”。至于这种突变是否是由于社会制度造成的，以及正确的调控手段是什么，就不在本文讨论之列了。</p>"},{"title":"Lambda表达式中的arguments","url":"http://sparkshining.com/2015/11/02/arguments-in-lambda/","content":"<p>最近在一个项目中遇到了这个坑，记下来，以警来者。</p>\n<p>JavaScript在ES2015中初次引入了箭头函数（Arrow Function）这一俗称“lambda表达式”的概念，用来解决代码中this容易用错的问题（注意，this的定义从来就没有歧义，但确实是有点“反直觉”，容易被曾使用过其他语言的开发者误用）。想要了解这一特性，可以参阅\n    <a href=\"http://es6.ruanyifeng.com/#docs/function\" target=\"_blank\" rel=\"external\">这篇介绍ES6的文章</a>中“箭头函数”一节（原文中已对本文所述的问题做了介绍）。</p>\n<p>在\n    <a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-arrow-function-definitions-runtime-semantics-evaluation\" target=\"_blank\" rel=\"external\">ES2015语言规范</a>中，明确规定了箭头函数不定义arguments的本地绑定。换句话说，如果在箭头函数中使用了arguments，则其值为生成该函数的参数列表，比如下面代码：\n    <br>\n    <figure class=\"highlight javascript\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> praise = getFunction(<span class=\"string\">'You suck!'</span>);</span><br><span class=\"line\">praise(<span class=\"string\">'You are great!'</span>);</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>如果在支持ES2015的浏览器（比如最新版的Chrome，笔者版本为46.0）上执行时你会发现，控制台会打印如下结果：\n    <br>\n    <figure class=\"highlight plain\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\">You suck!</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>而不是直觉上的You are great!</p>\n<p>本来这个问题比较简单，规范上面这么定义的，这么做就是了。偏偏有人来搅局了：在ES2015尚未发布之前，\n    <a href=\"http://www.typescriptlang.org/\" target=\"_blank\" rel=\"external\">TypeScript</a>（一个微软推出的语言，为JavaScript的超集，由于与Angular 2和React的合作而逐渐被人所知）就定义了类似的功能并最初起名为Lambda(现已改为采用跟ES2015一致的术语“箭头函数”，但截至笔者写作本文时，有些文档尚未更新，比如\n    <a href=\"http://www.typescriptlang.org/Handbook#functions-lambdas-and-using-39this39\" target=\"_blank\" rel=\"external\">这里</a>)。在TypeScript中，\n    <strong>起初</strong>并未对Lambda中的arguments做任何处理，因此，arguments所指向的就是最终函数的参数列表。也就是说如果你在TypeScript中编写了上文的程序，得到的打印结果就是You are great!。\n    <br>幸运的是，TypeScript的开发者即时地意识到了这一点（见\n    <a href=\"https://github.com/Microsoft/TypeScript/issues/1609\" target=\"_blank\" rel=\"external\">这个TypeScript问题</a>）。因此，如果在lambda中使用了arguments，你会得到如下的结果：</p>\n<ol>\n    <li>在TypeScript 1.5之前，该代码顺利通过编译，生成与E2015语义不一致的代码</li>\n    <li>在TypeScript 1.5之后，如果编译目标是ES6，该代码会顺利通过编译，生成箭头函数</li>\n    <li>在TypeScript 1.5之后，如果编译目标是ES3或者ES5，则该代码不会通过编译，错误如下：\n        <figure class=\"highlight plain\">\n            <table>\n                <tr>\n                    <td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td>\n                    <td class=\"code\"><pre><span class=\"line\">error TS2496: The &apos;arguments&apos; object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.</span><br></pre></td>\n                </tr>\n            </table>\n        </figure>\n    </li>\n</ol>"},{"title":"我的中医观","url":"http://sparkshining.com/2015/10/19/traditional-chinese-medical-science/","content":"<p>最近也许是因为屠呦呦的诺贝尔获奖，千年大坑“中医是不是科学”又烽烟再起，争论愈演愈烈。思考良久，颇有心得，于是诉诸笔端。笔者知识有限，有些观点可能有误，欢迎斧正。</p>\n<h3 id=\"中医是不是科学\">\n    <a href=\"#中医是不是科学\" class=\"headerlink\" title=\"中医是不是科学\"></a>中医是不是科学</h3>\n<p>说实话，经过我的观察，我觉得这个问题其实大家彼此异议最小。别急，听我慢慢道来。\n    <br>前两天看到了一篇文章，说到人们讨论的问题可以分为三类：一是事实性问题，就是讨论一见事情是否符合事实，多半这类问题可以转变成答案是“是”或者“否”的问题，比如今早吃没吃鸡蛋，这类问题有着唯一正确的结论，因为符合和没符合事实是互斥的；二是偏好性问题，就是你是否喜欢一个事物，比如红的好看还是绿的好看，这类问题没有错误的结论，因为不同人喜好不同；三是判断性问题，就是你对一个事物或现象的看法，这类问题的答案有多个，取决于你观察问题的角度。\n    <br>然而在我看来，这个归类法存在一个陷阱，那就是一个问题如果要成为事实性问题，必须其表述上是没有歧义的，而且这个唯一的含义能够得到所有参与讨论问题的人的认同。\n    <br>比如下面这个问题：太阳是否从东方升起？表面上看起来这是个事实性问题，答案只有“是”或者“否”，而且正确答案应该是“是”。但是你有没有想过，什么叫做“东方”，什么叫做“升起”呢？当你考虑过这些维度之后，你就会发现这个问题的答案不那么简单了：</p>\n<ol>\n    <li>太阳是不会自行升起的。我们只是在地球表面的一个观察点，基于地球自转的运动参照系观察到太阳在远离地心这个维度上有高度的上升变化。</li>\n    <li>这个观察点不包括南北极两个点，因为南极点只有北方而北极点只有南方。</li>\n    <li>东方表示的是以东方为中心，误差为23度26分21.448秒的一个方向的范围。否则，只有春分秋分那两天，太阳才是从非常接近东方的方向（还不能说是绝对的东方）升起的。有意思的是，对于我国绝大部分地区来说，冬至那天的太阳升起时的方向，距离正东北方反倒更接近些。</li>\n</ol>\n<p>那么，回到“中医是不是科学”这个问题：表面看起来，它是一个答案是“是”或者“否”的事实性问题。但是，如果认为这个问题有着唯一正确的结论，需要大家认可一个唯一的对“中医”和“科学”这两个概念的解释。很可惜，这样的无二义性的解释并不存在。笔者试着用一些没有二义性的方式来表述一些本人的看法，大家可以对照一下，是不是同自己的理解是一样的：</p>\n<ol>\n    <li>以下表述中，中医的定义为：主流的研究并发展“中医”这一概念的学者所认同的基于中国传统的对于医疗方向知识所总结的一套学说体系。西医的定义为：基于解剖学、物理学、化学、生物学、分子生物学等其他学科，辅以实验以及数据分析的对于医疗方向知识所总结的一套学说体系。</li>\n    <li>中医学说体系与西医学说体系在问题定义以及验证方法尚存在分歧。换句话说，目前并不存在双方均认可的问题定义和验证方法。</li>\n    <li>按照中医所提出的问题定义和验证方法，中医学说体系是可以通过实验方法验证的。</li>\n    <li>目前尚无足够多的数据对中医学说体系的基础理论证实或者证伪。</li>\n    <li>西医中主流学者对于是否存在一种方式将中医与西医两种学说统一起来存在争议。</li>\n</ol>\n<p>之所以列了这么多条，是因为“科学”这一概念的解释方式很多，这里只是采纳了主流的几种解释（可验证论、证伪论、科学共同体论）。如果您认同上面所说的所有条目，那么我们的观点是一致的。至于中医是不是科学，那取决于您如何定义“中医”与“科学”了。</p>\n<h3 id=\"该如何对待中医\">\n    <a href=\"#该如何对待中医\" class=\"headerlink\" title=\"该如何对待中医\"></a>该如何对待中医</h3>\n<p>医学与其他学科的不同在于，医学的学说建立存在着较大的滞后性。也就是说，无论是西医或者中医，都存在着大量无法解释的现象，也都存在很多不明机理但却有效的治疗方式。作为在一个存在大量未知现象的领域的一种学说体系，简单地说保留或者废除都是不合时宜的。其实完全可以按照市场化的方式，让其自己发展或者消亡。在某一领域，至少如果一种学说体系无法完全给出完整的解决方案之前，其他学说体系的存在都是有意义的。\n    <br>作为每天需要使用医学结论的普通人，在面对治疗方案时，其实是一个对于投资回报的判断：如果我按照这个治疗方案进行投资，那么我有多大的可能会获得这个治疗方案所宣称的结果。这个时候，你要考虑的不是那个在诸多限制条件下的学术上的结论。治疗方案提出者是否了解学说本身，安慰剂等诸多浮动效应有多大可能发生都是考察的对象。比如说，假如有这样的一个理论，它虽然完全不能自洽，但是按照这个理论的手段能够保证百分之百出现安慰剂效应（当然很可能是由于某个尚未发现的原因）从而治好你的病，你愿不愿意采用呢？再比如，有一个医学理论，可以百分之百治好你的病，但是能够准确理解这个理论的医生万里也挑不出一个来，你愿不愿意采用眼前的医生基于这个理论提出来的解决方案呢？所以，是否采纳中/西医的解决方案，跟上面那个“中医是不是科学”问题完全是两个问题。这是一个个人做出的判断，风险自担，跟别人无关（只是不管是哪一种解决方案，准确地了解是否已研究过副作用或者是否有已知的副作用是基本的权利）。</p>\n<h3 id=\"几个误区\">\n    <a href=\"#几个误区\" class=\"headerlink\" title=\"几个误区\"></a>几个误区</h3>\n<p>我们在思考问题的时候，经常会走入一些误区。准确地识别出它们，是独立思考的一个必要的步骤。</p>\n<ol>\n    <li>在一个学说体系中，曾经提出的一个学说，如果没有被现在该学说体系的主流学者认同，则并不能视为是该学说体系的一部分。比如亚里士多德曾提出力是维持物体匀速运动的原因，我们不能认为这是物理学所秉持的观点。因此，如果你发现某古医书里写治疟疾要让大公鸡喊两声，也不能认为这是中医的观点。</li>\n    <li>不能将一个学说的概念套用在另一个学说上并作为反驳的基础，这是因为两者问题定义不同。比如我们不能因为球面几何中不存在欧式几何中平行线这个概念而认为球面几何是错误的。因此，利用中药如果不能提供维生素就无法治疗维生素引发的疾病反驳中医也是没有道理的。</li>\n    <li>观察不到的概念不等于不存在。你不能因为观察不到某些微观粒子而否定某些量子物理学说，不能因为看不到插件而否定这一编程概念，同样你也不能因为无法从解剖中看不到经脉而否定它（当然你可以用其他方式来否定）。</li>\n    <li>表述方式原始的概念不等于不正确。有些概念有可能沿用了几千年，表述起来自然听起来不那么现代。但是概念是否正确跟这关系不大。比如苗这个概念用了上千年，却并不妨碍我们使用它来解释疫苗。中医的五行也并不是说你发烧的时候身体里就真的有物质在剧烈燃烧。只是如果一个学说体系想要得到发展，准确的阐释每个概念是非常必要的。</li>\n</ol>"},{"title":"通俗地解释第三方登录","url":"http://sparkshining.com/2015/10/14/common-third-party-authentication/","content":"<p>最近正在做SAML相关的事情，苦于没有一个第三方登录流程的通俗解释。结合以前做过的OpenID，试着自己解释一下。以下故事中机构名与人名均属化名，如有雷同，纯属巧合。</p>\n<p>话说最近上海开了一家“人间天上”高级程序员休闲会所，供程序员在里面聊聊算法、思考人生。一天，有一个衣着入时的美女来找会所看门的王二狗，该美女自称是高级程序员，名叫郭小美，要求入会。王二狗又不是混程序圈的，咋知道这个人该不该放进去呢？于是王二狗请示安保主管雷老大。雷老大眼睛一瞪：老子又不是神仙，咋知道？\n    <br>不过雷老大不愧是雷老大，经得多见得广，这点小事难不倒他。雷老大亲自接见郭小美，几个来回，事情就办成了：</p>\n<ol>\n    <li>雷老大拱了拱手：没听说过姑娘的名号，不知道是那路的？郭小美嫣然一笑：瞧您说的，没点背景还敢来？我是高级程序员协会的。</li>\n    <li>雷老大大腿一拍：这就好办了，认识高级程序员协会会长盖茨比么？郭小美一愣：当然认识了，我干爹呀。</li>\n    <li>雷老大嘿嘿一笑：这就更不是外人了。可惜这入会严格的规矩上面定的，我也没办法，要不你让盖茨比批个条子拿来，也让兄弟方便？郭小美皱了皱眉：真麻烦，好吧，就这么办！</li>\n    <li>郭小美去找盖茨比，凭借着两人深厚的革命友谊，很快条子拿来了。上面一行字：兹证明郭小美（女，身份证号XXX，三围XXX）是高级程序员协会会员——盖茨比。笔锋苍劲，一看就是练过的。</li>\n</ol>\n<p>看到条子，雷老大满脸堆笑：不好意思呀，还让郭小姐多跑了一趟。回头招呼王二狗：傻站着干啥，赶紧办理入会！</p>"},{"title":"zone.js简介","url":"http://sparkshining.com/2015/10/10/introduction-to-zone-js/","content":"<p>当你使用Angular 2的时候，你会惊喜地发现你不再需要$rootScope.$apply了，即使你直接调用addEventListener挂载一个事件处理器偷偷修改了模型，也不需要通知Angular。Angular似乎能够“未卜先知”地知道你的所有小动作。这一切的功劳都归功于zone.js。</p>\n<p>zone.js的github地址见\n    <a href=\"https://github.com/angular/zone.js\" target=\"_blank\" rel=\"external\">这里</a>。原代码库提供了一个\n    <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\" target=\"_blank\" rel=\"external\">ng-conf上的video</a>(需翻墙)来解释这个库的背景。注意\n    <strong>zone.js是一个独立的库，并不依赖于Angular</strong>，所以你无需担心被“某些别有用心的大户”挟持了。</p>\n<p>简单地说，zone.js允许你为一段代码及其衍生出的代码提供了一个统一的上下文（zone.js称之为zone）。这个概念类似Node中的domain或者Java中的thread locals。\n    <br>能够在源于同一段代码的有着不同stack trace的程序间共享数据是一件很诱人的事情。比如说，你想统计程序的执行时间，然而你却有这样的一段奇葩程序：它自己要执行1秒，并且触发一个异步的操作；这个异步的操作又执行了3秒。如果你能够在这两段程序间共享数据，这个问题就简单多了。\n    <br>当然，你完全可以自己通过给每个入口的地方都加入一段代码的方式来解决这个问题，但是你会更希望能够使用一种类似zone.js提供的这种“面向切面”的优雅解决方案。</p>\n<p>首先，如果用这样的方式来运行你的程序：\n    <br>\n    <figure class=\"highlight javascript\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\">zone.run(yourCode);</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>这样你的这段代码以及其衍生的代码，包括：</p>\n<ol>\n    <li>它注册的浏览器事件处理器</li>\n    <li>它通过setTimeout和setInterval在未来执行的代码</li>\n</ol>\n<p>以及衍生代码所衍生的代码就共享一个zone了。</p>\n<p>那么，怎么使用这个zone呢？你可以通过类似下面这段代码这样通过zone.fork来插入一些监听器：\n    <br>\n    <figure class=\"highlight javascript\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\">zone.fork(&#123;</span><br><span class=\"line\">  beforeTask: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在每段代码执行前都会执行的代码</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  afterTask: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在每段代码执行后都会执行的代码</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).run(youCode);</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>比如，在beforeTask记录下开始时间，afterTask时记录下结束时间、与开始时间比较算出执行时间并且累加，你就可以解决前文说过的那个问题了。本文开头的Angular 2的$rootScope.$apply的迷雾也就解开了，因为Angular 2使用了zone并且在afterTask时帮你执行这个了。</p>\n<p>zone.js的实现原理很简单，就是mock掉你的每个入口位置。多么地简单粗暴啊！但是非常有效。</p>\n<p>说了这么多，来看一个最最简单地例子吧：我们想在每次执行代码(主函数、事件监听函数和setTimeout加入的macrotask)的前后各打印一行log。</p>\n<p>首先，我们新创建一个空文件夹来装例子所需的文件。\n    <br>然后，因为zone支持bower，我们通过在该文件夹中运行下面的命令(有关bower使用，请见\n    <a href=\"http://bower.io/#getting-started\" target=\"_blank\" rel=\"external\">这里</a>)下载zone：\n    <br>\n    <figure class=\"highlight bash\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\">bower install zone</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>然后，在目录下创建index.html文件。那么默认情况下，相对于html文件，zone.js文件的位置应该是”bower_components/zone/dist/zone.js”。html文件内容如下\n    <br>\n    <figure class=\"highlight html\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Zone.js Basic Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./bower_components/zone/dist/zone.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Basic Example<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"trigger\"</span>&gt;</span>Run async code<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span><br><span class=\"line\">     * This is a simple example of async stack traces with zones</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Run main'</span>);</span><br><span class=\"line\">        trigger.addEventListener(<span class=\"string\">'click'</span>, clickHandler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clickHandler</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Run click handler'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'Run macro task'</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span><br><span class=\"line\">     * Bootstrap the app</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    zone.fork(&#123;</span><br><span class=\"line\">        beforeTask: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'Enter zone'</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        afterTask: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'Leave zone'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).run(main);</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>然后你可以用类似\n    <a href=\"https://github.com/indexzero/http-server\" target=\"_blank\" rel=\"external\">http-server</a>的方法来部署这个文件并用浏览器访问。\n    <br>在页面加载后，你会在控制台看到如下信息\n    <br>\n    <figure class=\"highlight python\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\">Enter zone</span><br><span class=\"line\">Run main</span><br><span class=\"line\">Leave zone</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>当点击页面中的按钮时，控制台会打印如下信息\n    <br>\n    <figure class=\"highlight python\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\">Enter zone</span><br><span class=\"line\">Run click handler</span><br><span class=\"line\">Leave zone</span><br><span class=\"line\">Enter zone</span><br><span class=\"line\">Run macro task</span><br><span class=\"line\">Leave zone</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>值得指出的是，zone.js那个文件本身并不支持microtask（有关macrotask和microtask，日后我会专门写一篇文章来解释）。如果想支持microtask，你需要使用库里面的zone-microtask.js。这个文件比zone.js大很多，主要的原因是它用es6-promise完全替换掉了浏览器内置的Promise。</p>"},{"title":"如何生成一个安全的随机数","url":"http://sparkshining.com/2015/10/09/js-safe-get-random/","content":"<p>提起随机数，大家的第一反应一般是Math.random。然而，\n    <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-15.8.2.14\" target=\"_blank\" rel=\"external\">ECMAScript里面</a>(中文版见\n    <a href=\"http://lzw.me/pages/ecmascript/#457\" target=\"_blank\" rel=\"external\">这里</a>)并没有规定用什么算法来实现这个API，只是规定了生成的数字应该在[0, 1)内近似均匀分布。这就使得很多引擎实现在实现时采用了比较简单地算法，并不保证随机数的不可预测。\n    <br>这样的随机数显然不能用于数据加密。那么，有什么API可以获得一个安全的随机数呢？</p>\n<p>如果是Node.js，你可以使用\n    <a href=\"https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback\" target=\"_blank\" rel=\"external\">crypto.randomBytes(size[, callback])</a>这个API，比如下面的code获得了一个包含4个byte的随机数：\n    <br>\n    <figure class=\"highlight javascript\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\">crypto.randomBytes(<span class=\"number\">4</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buf</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(buf.length);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(buf[<span class=\"number\">0</span>], buf[<span class=\"number\">1</span>], buf[<span class=\"number\">2</span>], buf[<span class=\"number\">3</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>那浏览器端怎么办呢，你可以使用\n    <a href=\"http://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues\" target=\"_blank\" rel=\"external\">crypto.getRandomValues(array)</a>这个API，现在很多浏览器都支持这个API了（具体浏览器支持情况请见\n    <a href=\"http://caniuse.com/#feat=getrandomvalues\" target=\"_blank\" rel=\"external\">这里</a>），比如下面的code获得了一个Uint32（4个byte）的随机数：\n    <br>\n    <figure class=\"highlight javascript\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint32Array</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">crypto.getRandomValues(buffer);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buffer[<span class=\"number\">0</span>]);</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>搞定，收工！</p>"},{"title":"自定义JS对象的序列化与反序列化过程","url":"http://sparkshining.com/2015/10/08/jsobject-serialization-deserialization/","content":"<p>先更正一个概念，JSON是一种数据表达的格式（见\n    <a href=\"http://www.ietf.org/rfc/rfc4627.txt\" target=\"_blank\" rel=\"external\">RFC-4627</a>），就像我们平常说的xml、csv一样。它本身不是数据，也不依赖于具体编程语言。用.net、Java或者Python都能生成JSON格式的数据。\n    <br>\n    <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-15.12\" target=\"_blank\" rel=\"external\">JSON对象(JSON Object)</a>(中文文档见\n    <a href=\"http://lzw.me/pages/ecmascript/#609\" target=\"_blank\" rel=\"external\">这里</a>)这个术语是有的，它是全局对象众多属性中的一个。它包含两个函数：parse和stringify，用于解析和构造JSON文本。但是JSON对象跟\n    <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5\" target=\"_blank\" rel=\"external\">对象初始化(Object Initialiser)</a>(中文文档见\n    <a href=\"http://lzw.me/pages/ecmascript/#159\" target=\"_blank\" rel=\"external\">这里</a>)是两码事，后者用于以直接量的方式初始化一个对象，比如\n    <br>\n    <figure class=\"highlight javascript\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; myField: <span class=\"string\">'myValue'</span> &#125;;</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>注意不要弄混了。</p>\n<p>其实JSON.stringify和JSON.parse的参数都不止一个，根据ECMAScript 5.1规范，两者的声明分别是：\n    <br>\n    <figure class=\"highlight css\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">JSON</span><span class=\"selector-class\">.stringify</span>(<span class=\"selector-tag\">value</span> <span class=\"selector-attr\">[ , replacer [ , space ]</span> ] )</span><br><span class=\"line\"><span class=\"selector-tag\">JSON</span><span class=\"selector-class\">.parse</span>(<span class=\"selector-tag\">text</span> <span class=\"selector-attr\">[ , reviver ]</span> )</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>这就使得我们可以控制序列化和反序列化的过程。比如下面的代码模拟了一个让函数在序列化并反序列化后仍旧保持不丢失的情况。\n    <br>\n    <figure class=\"highlight javascript\">\n        <table>\n            <tr>\n                <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td>\n                <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  myField: <span class=\"string\">'myValue'</span>,</span><br><span class=\"line\">  myFunction: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'function is not able to be serialized'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replacer</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> value === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'__function'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> JSONString = <span class=\"built_in\">JSON</span>.stringify(obj, replacer);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reviver</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value === <span class=\"string\">'__function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'function restored by reviver'</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> restoredObj = <span class=\"built_in\">JSON</span>.parse(JSONString, reviver);</span><br><span class=\"line\">restoredObj.myFunction();</span><br></pre></td>\n            </tr>\n        </table>\n    </figure>\n</p>\n<p>值得注意的是，除了函数外，replacer还支持其他几种类型。有兴趣的请翻阅\n    <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3\" target=\"_blank\" rel=\"external\">ECMAScript规范相关部分</a>(中文版见\n    <a href=\"http://lzw.me/pages/ecmascript/#614\" target=\"_blank\" rel=\"external\">这里</a>)。最有意思的是，你还可以通过定义toJSON函数来自定义序列化的过程。</p>"},{"title":"开篇志","url":"http://sparkshining.com/2015/08/27/hello-world/","content":"<p>一个雨后的黄昏，一杯清茶，一支笔，一张纸。就此开始。</p>\n<p>其实上大学那会儿，还是个挺矫情的人，没事就写点东西。等工了作，成了家，有了孩子，事情一多，也就慢慢变得大条了。\n    <br>当然，也是生活舒适了，没那么多伤春悲秋的事。\n    <br>一晃七八年，猛然发现竟然没留下什么印象。偶尔翻翻照片，一片陌生。\n    <br>觉得有点对不起自己，也对不起那些重要的人。本是萍水相逢，却逐渐印入对方的生活。其间曲曲折折，竟这样逐渐淡了。\n    <br>未来之路还很长，不求别的，只求能留下些印记，为自己，也为重要的人。</p>\n<p>工作亦是如此，几年下来，颇有些心得。本是好为人师的，只因太懒，几次冲动最后都只是动了动嘴皮子。\n    <br>其间，跟着公司一位前辈一起出了一本书，写的是一个小众的框架，出版后据说风评还不错。\n    <br>那段时间废寝忘食，写的很是酣畅淋漓。等书出版以后，懒心又起，原来CSDN的博客就这样彻底荒掉了。</p>\n<p>我虽然喜欢技术，却只限于工作或是猎奇。生活中却是保守得很。\n    <br>在移动上网3G、4G如火如荼的时候，我还揣着一台老旧的Nokia，除了打电话发短信，跟网络没有半毛钱关系。\n    <br>支付宝是去年才开始用的，滴滴打车是上个月才开始用的。人家咣咣往里砸钱，补贴满天飞的时候，我依旧去超市买东西，坐地铁上下班。\n    <br>个人网站也是这样，虽然我的工作一直跟网页相关，却从来没有一个自己的网站。\n    <br>没什么，不感冒而已。</p>\n<p>偶然一个机会，一时冲动，买了个域名。买完之后，花了几分钟做了个巨丑陋的“网站正在建设中”的页面，而后就放在那儿。\n    <br>结果没出两个月，接了无数来自百度推广市场部的电话，后来连自己都烦了。既然已经被骚扰了，不妨就写点什么吧。</p>\n<p>花了些时间，搞了个自己看着还算凑合的模板，用hexo搭了个台子。就这样，今天算是开张了。\n    <br>其实这里充其量只能算是个自留地，能记录下生活技术上的点点滴滴，也就知足了。</p>"}]